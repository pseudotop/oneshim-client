// This file is @generated by prost-build.
/// 로그인 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    /// 식별자 (email, username, phone)
    #[prost(string, tag = "1")]
    pub identifier: ::prost::alloc::string::String,
    /// 비밀번호
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// 조직 ID
    #[prost(string, tag = "3")]
    pub organization_id: ::prost::alloc::string::String,
    /// 디바이스 정보 (OS, 버전, 앱 버전 등)
    #[prost(map = "string, string", tag = "4")]
    pub device_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// 디바이스 기억 여부
    #[prost(bool, tag = "5")]
    pub remember_device: bool,
    /// MFA 토큰 (2차 인증이 필요한 경우)
    #[prost(string, optional, tag = "6")]
    pub mfa_token: ::core::option::Option<::prost::alloc::string::String>,
}
/// 로그인 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponse {
    /// 성공 여부
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// 메시지 (실패 시 에러 메시지)
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// 사용자 ID
    #[prost(string, tag = "3")]
    pub user_id: ::prost::alloc::string::String,
    /// 사용자명
    #[prost(string, tag = "4")]
    pub username: ::prost::alloc::string::String,
    /// 이메일
    #[prost(string, tag = "5")]
    pub email: ::prost::alloc::string::String,
    /// 조직 ID
    #[prost(string, tag = "6")]
    pub organization_id: ::prost::alloc::string::String,
    /// Access Token (JWT)
    #[prost(string, tag = "7")]
    pub access_token: ::prost::alloc::string::String,
    /// Refresh Token
    #[prost(string, tag = "8")]
    pub refresh_token: ::prost::alloc::string::String,
    /// 토큰 타입 ("Bearer")
    #[prost(string, tag = "9")]
    pub token_type: ::prost::alloc::string::String,
    /// 만료 시간 (초)
    #[prost(int32, tag = "10")]
    pub expires_in: i32,
    /// 세션 ID
    #[prost(string, tag = "11")]
    pub session_id: ::prost::alloc::string::String,
    /// MFA 필요 여부
    #[prost(bool, tag = "12")]
    pub requires_mfa: bool,
    /// MFA 방법 목록
    #[prost(string, repeated, tag = "13")]
    pub mfa_methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 사용자 권한 목록
    #[prost(string, repeated, tag = "14")]
    pub user_permissions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 사용자 역할 목록
    #[prost(string, repeated, tag = "15")]
    pub user_roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 응답 시각
    #[prost(message, optional, tag = "16")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// 요청 ID
    #[prost(string, optional, tag = "17")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// 로그아웃 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogoutRequest {
    /// 사용자 ID
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// 세션 ID (특정 세션만 로그아웃)
    #[prost(string, optional, tag = "2")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    /// 모든 디바이스 로그아웃 여부
    #[prost(bool, tag = "3")]
    pub logout_all_devices: bool,
    /// 로그아웃 사유
    #[prost(string, optional, tag = "4")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// 로그아웃 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogoutResponse {
    /// 성공 여부
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// 메시지
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// 응답 시각
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// 토큰 갱신 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTokenRequest {
    /// Refresh Token
    #[prost(string, tag = "1")]
    pub refresh_token: ::prost::alloc::string::String,
    /// 사용자 ID
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// 세션 ID
    #[prost(string, optional, tag = "3")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// 토큰 갱신 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenRefreshResponse {
    /// 새 Access Token
    #[prost(string, tag = "1")]
    pub access_token: ::prost::alloc::string::String,
    /// 새 Refresh Token (회전 시)
    #[prost(string, optional, tag = "2")]
    pub refresh_token: ::core::option::Option<::prost::alloc::string::String>,
    /// 토큰 타입
    #[prost(string, tag = "3")]
    pub token_type: ::prost::alloc::string::String,
    /// 만료 시간 (초)
    #[prost(int32, tag = "4")]
    pub expires_in: i32,
    /// 세션 연장 여부
    #[prost(bool, tag = "5")]
    pub session_extended: bool,
    /// 응답 시각
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// 토큰 검증 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateTokenRequest {
    /// 토큰
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// 토큰 타입 ("access" | "refresh")
    #[prost(string, tag = "2")]
    pub token_type: ::prost::alloc::string::String,
    /// 만료 검증 여부
    #[prost(bool, tag = "3")]
    pub validate_expiry: bool,
    /// 서명 검증 여부
    #[prost(bool, tag = "4")]
    pub validate_signature: bool,
}
/// 토큰 검증 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenValidationResponse {
    /// 유효 여부
    #[prost(bool, tag = "1")]
    pub is_valid: bool,
    /// 사용자 ID
    #[prost(string, optional, tag = "2")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    /// 만료 시각
    #[prost(message, optional, tag = "3")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 토큰 타입
    #[prost(string, optional, tag = "4")]
    pub token_type: ::core::option::Option<::prost::alloc::string::String>,
    /// 스코프 목록
    #[prost(string, repeated, tag = "5")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserRole {
    Unspecified = 0,
    SuperAdmin = 1,
    Admin = 2,
    Manager = 3,
    Staff = 4,
    User = 5,
    Guest = 6,
}
impl UserRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_ROLE_UNSPECIFIED",
            Self::SuperAdmin => "USER_ROLE_SUPER_ADMIN",
            Self::Admin => "USER_ROLE_ADMIN",
            Self::Manager => "USER_ROLE_MANAGER",
            Self::Staff => "USER_ROLE_STAFF",
            Self::User => "USER_ROLE_USER",
            Self::Guest => "USER_ROLE_GUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_ROLE_SUPER_ADMIN" => Some(Self::SuperAdmin),
            "USER_ROLE_ADMIN" => Some(Self::Admin),
            "USER_ROLE_MANAGER" => Some(Self::Manager),
            "USER_ROLE_STAFF" => Some(Self::Staff),
            "USER_ROLE_USER" => Some(Self::User),
            "USER_ROLE_GUEST" => Some(Self::Guest),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SessionStatus {
    Unspecified = 0,
    Initial = 1,
    Active = 2,
    Expired = 3,
    Invalidated = 4,
    Terminated = 5,
    Revoked = 6,
}
impl SessionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SESSION_STATUS_UNSPECIFIED",
            Self::Initial => "SESSION_STATUS_INITIAL",
            Self::Active => "SESSION_STATUS_ACTIVE",
            Self::Expired => "SESSION_STATUS_EXPIRED",
            Self::Invalidated => "SESSION_STATUS_INVALIDATED",
            Self::Terminated => "SESSION_STATUS_TERMINATED",
            Self::Revoked => "SESSION_STATUS_REVOKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SESSION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SESSION_STATUS_INITIAL" => Some(Self::Initial),
            "SESSION_STATUS_ACTIVE" => Some(Self::Active),
            "SESSION_STATUS_EXPIRED" => Some(Self::Expired),
            "SESSION_STATUS_INVALIDATED" => Some(Self::Invalidated),
            "SESSION_STATUS_TERMINATED" => Some(Self::Terminated),
            "SESSION_STATUS_REVOKED" => Some(Self::Revoked),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MfaMethod {
    Unspecified = 0,
    Totp = 1,
    Sms = 2,
    Email = 3,
    BackupCode = 4,
}
impl MfaMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MFA_METHOD_UNSPECIFIED",
            Self::Totp => "MFA_METHOD_TOTP",
            Self::Sms => "MFA_METHOD_SMS",
            Self::Email => "MFA_METHOD_EMAIL",
            Self::BackupCode => "MFA_METHOD_BACKUP_CODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MFA_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "MFA_METHOD_TOTP" => Some(Self::Totp),
            "MFA_METHOD_SMS" => Some(Self::Sms),
            "MFA_METHOD_EMAIL" => Some(Self::Email),
            "MFA_METHOD_BACKUP_CODE" => Some(Self::BackupCode),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod authentication_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct AuthenticationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AuthenticationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AuthenticationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AuthenticationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AuthenticationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 로그인
        pub async fn login(
            &mut self,
            request: impl tonic::IntoRequest<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.AuthenticationService/Login",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.AuthenticationService", "Login"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 로그아웃
        pub async fn logout(
            &mut self,
            request: impl tonic::IntoRequest<super::LogoutRequest>,
        ) -> std::result::Result<tonic::Response<super::LogoutResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.AuthenticationService/Logout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.AuthenticationService", "Logout"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 토큰 갱신
        pub async fn refresh_token(
            &mut self,
            request: impl tonic::IntoRequest<super::RefreshTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TokenRefreshResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.AuthenticationService/RefreshToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "oneshim.v1.auth.AuthenticationService",
                        "RefreshToken",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 토큰 검증
        pub async fn validate_token(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TokenValidationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.AuthenticationService/ValidateToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "oneshim.v1.auth.AuthenticationService",
                        "ValidateToken",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// 세션 정보
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    /// 세션 ID
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// 사용자 ID
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// 클라이언트 ID
    #[prost(string, tag = "3")]
    pub client_id: ::prost::alloc::string::String,
    /// 세션 상태
    #[prost(enumeration = "SessionStatus", tag = "4")]
    pub status: i32,
    /// 생성 시각
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 최종 활동 시각
    #[prost(message, optional, tag = "6")]
    pub last_activity_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 만료 시각
    #[prost(message, optional, tag = "7")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 디바이스 정보
    #[prost(map = "string, string", tag = "8")]
    pub device_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// IP 주소
    #[prost(string, optional, tag = "9")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// User Agent
    #[prost(string, optional, tag = "10")]
    pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
}
/// 세션 생성 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
    /// 클라이언트 ID (UUID)
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    /// 디바이스 정보
    #[prost(map = "string, string", tag = "2")]
    pub device_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// IP 주소
    #[prost(string, optional, tag = "3")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// User Agent
    #[prost(string, optional, tag = "4")]
    pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
}
/// 세션 생성 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionResponse {
    /// 생성된 세션
    #[prost(message, optional, tag = "1")]
    pub session: ::core::option::Option<Session>,
    /// Access Token
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
    /// Refresh Token
    #[prost(string, tag = "3")]
    pub refresh_token: ::prost::alloc::string::String,
    /// 만료 시간 (초)
    #[prost(int32, tag = "4")]
    pub expires_in: i32,
}
/// 세션 조회 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionRequest {
    /// 세션 ID
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
}
/// 세션 목록 조회 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
    /// 사용자 ID (현재 사용자의 세션만)
    #[prost(string, optional, tag = "1")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    /// 활성 세션만 조회
    #[prost(bool, tag = "2")]
    pub active_only: bool,
    /// 페이지네이션
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::common::PaginationRequest>,
}
/// 세션 목록 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    /// 세션 목록
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    /// 페이지네이션 메타
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::PaginationMeta>,
}
/// 세션 종료 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndSessionRequest {
    /// 세션 ID
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// 종료 사유
    #[prost(string, optional, tag = "2")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// 세션 하트비트 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionHeartbeatRequest {
    /// 세션 ID
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// 클라이언트 타임스탬프
    #[prost(message, optional, tag = "2")]
    pub client_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// 클라이언트 상태 정보
    #[prost(map = "string, string", tag = "3")]
    pub client_state: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 세션 하트비트 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionHeartbeatResponse {
    /// 성공 여부
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// 서버 타임스탬프
    #[prost(message, optional, tag = "2")]
    pub server_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// 서버 지시사항
    #[prost(map = "string, string", tag = "3")]
    pub instructions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// 세션 만료까지 남은 시간 (초)
    #[prost(int32, tag = "4")]
    pub ttl_seconds: i32,
}
/// Generated client implementations.
pub mod session_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SessionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SessionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SessionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SessionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SessionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 세션 생성
        pub async fn create_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.SessionService/CreateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.SessionService", "CreateSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 세션 조회
        pub async fn get_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.SessionService/GetSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("oneshim.v1.auth.SessionService", "GetSession"));
            self.inner.unary(req, path, codec).await
        }
        /// 세션 목록 조회
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.SessionService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.SessionService", "ListSessions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 세션 종료
        pub async fn end_session(
            &mut self,
            request: impl tonic::IntoRequest<super::EndSessionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.SessionService/EndSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("oneshim.v1.auth.SessionService", "EndSession"));
            self.inner.unary(req, path, codec).await
        }
        /// 세션 하트비트
        pub async fn heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::SessionHeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SessionHeartbeatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.SessionService/Heartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("oneshim.v1.auth.SessionService", "Heartbeat"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// 디바이스 정보
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Device {
    /// 디바이스 ID
    #[prost(string, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    /// 사용자 ID
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// 디바이스 타입
    #[prost(enumeration = "super::common::DeviceType", tag = "3")]
    pub device_type: i32,
    /// 플랫폼
    #[prost(enumeration = "super::common::Platform", tag = "4")]
    pub platform: i32,
    /// 디바이스 이름 (사용자 지정)
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// OS 버전
    #[prost(string, tag = "6")]
    pub os_version: ::prost::alloc::string::String,
    /// 앱 버전
    #[prost(string, tag = "7")]
    pub app_version: ::prost::alloc::string::String,
    /// 신뢰 여부
    #[prost(bool, tag = "8")]
    pub is_trusted: bool,
    /// 등록 시각
    #[prost(message, optional, tag = "9")]
    pub registered_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 최종 접속 시각
    #[prost(message, optional, tag = "10")]
    pub last_seen_at: ::core::option::Option<::prost_types::Timestamp>,
    /// 추가 메타데이터
    #[prost(map = "string, string", tag = "11")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 디바이스 등록 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterDeviceRequest {
    /// 디바이스 타입
    #[prost(enumeration = "super::common::DeviceType", tag = "1")]
    pub device_type: i32,
    /// 플랫폼
    #[prost(enumeration = "super::common::Platform", tag = "2")]
    pub platform: i32,
    /// 디바이스 이름
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// OS 버전
    #[prost(string, tag = "4")]
    pub os_version: ::prost::alloc::string::String,
    /// 앱 버전
    #[prost(string, tag = "5")]
    pub app_version: ::prost::alloc::string::String,
    /// 추가 메타데이터
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 디바이스 등록 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterDeviceResponse {
    /// 등록된 디바이스
    #[prost(message, optional, tag = "1")]
    pub device: ::core::option::Option<Device>,
    /// 디바이스 인증 토큰
    #[prost(string, tag = "2")]
    pub device_token: ::prost::alloc::string::String,
}
/// 디바이스 조회 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeviceRequest {
    /// 디바이스 ID
    #[prost(string, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
}
/// 디바이스 목록 조회 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDevicesRequest {
    /// 신뢰 디바이스만 조회
    #[prost(bool, tag = "1")]
    pub trusted_only: bool,
    /// 페이지네이션
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::PaginationRequest>,
}
/// 디바이스 목록 응답
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDevicesResponse {
    /// 디바이스 목록
    #[prost(message, repeated, tag = "1")]
    pub devices: ::prost::alloc::vec::Vec<Device>,
    /// 페이지네이션 메타
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::PaginationMeta>,
}
/// 디바이스 업데이트 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeviceRequest {
    /// 디바이스 ID
    #[prost(string, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    /// 디바이스 이름
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// 앱 버전
    #[prost(string, optional, tag = "3")]
    pub app_version: ::core::option::Option<::prost::alloc::string::String>,
    /// 신뢰 여부
    #[prost(bool, optional, tag = "4")]
    pub is_trusted: ::core::option::Option<bool>,
}
/// 디바이스 삭제 요청
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDeviceRequest {
    /// 디바이스 ID
    #[prost(string, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod device_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DeviceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeviceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeviceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeviceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeviceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 디바이스 등록
        pub async fn register_device(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterDeviceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterDeviceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.DeviceService/RegisterDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.DeviceService", "RegisterDevice"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 디바이스 조회
        pub async fn get_device(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeviceRequest>,
        ) -> std::result::Result<tonic::Response<super::Device>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.DeviceService/GetDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("oneshim.v1.auth.DeviceService", "GetDevice"));
            self.inner.unary(req, path, codec).await
        }
        /// 디바이스 목록 조회
        pub async fn list_devices(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDevicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDevicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.DeviceService/ListDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("oneshim.v1.auth.DeviceService", "ListDevices"));
            self.inner.unary(req, path, codec).await
        }
        /// 디바이스 업데이트
        pub async fn update_device(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeviceRequest>,
        ) -> std::result::Result<tonic::Response<super::Device>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.DeviceService/UpdateDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.DeviceService", "UpdateDevice"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 디바이스 삭제
        pub async fn remove_device(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDeviceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/oneshim.v1.auth.DeviceService/RemoveDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("oneshim.v1.auth.DeviceService", "RemoveDevice"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
